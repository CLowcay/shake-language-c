#!/usr/bin/env runhaskell
-- Copyright 2013 Samplecount S.L.
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

import           Control.Applicative ((<$>))
import           Control.Monad (when)
import           Data.Char (toLower)
import qualified Data.List as List
import qualified Distribution.PackageDescription as Dist
import qualified Distribution.PackageDescription.Configuration as Dist
import qualified Distribution.PackageDescription.Parse as Dist
import qualified Distribution.Verbosity as Dist
import qualified System.Directory as Dir
import qualified System.Environment as Env
import           System.Exit (ExitCode(..), exitFailure)
import           System.FilePath ((</>))
import           System.IO (hPutStrLn, stderr)
import           System.Process (rawSystem)

-- Cabal configuration fields:

configFieldPackageDirs :: String
configFieldPackageDirs = "x-stir-package-dirs"

configFieldSandbox :: String
configFieldSandbox = "x-stir-sandbox"

configFieldSandboxCommand :: String
configFieldSandboxCommand = "x-stir-sandbox-command"

-- Not yet in process-1.1
callProcess :: String -> [String] -> IO ()
callProcess path args = do
  exitCode <- rawSystem path args
  case exitCode of
    ExitSuccess -> return ()
    ExitFailure code -> error $ path ++ " failed with exit code " ++ show code

data Sandbox = Sandbox {
    update :: [FilePath] -> [String] -> IO ()
  , build :: String -> [String] -> IO ()
  , clean :: IO ()
  }

findExecutable :: String -> IO FilePath
findExecutable exe = maybe (error $ exe ++ " executable not found") id
                        <$> Dir.findExecutable exe

mkCabalDevSandbox :: Maybe FilePath -> IO Sandbox
mkCabalDevSandbox cmdPath = do
  cmd <- maybe (findExecutable "cabal-dev") return cmdPath
  let sandboxDir = "cabal-dev"
  return $ Sandbox {
      update = \sources args -> do
        mapM_ (\dir -> callProcess cmd ["add-source", dir])
              sources
        callProcess cmd $ ["install"] ++ args
    , build = \exe -> callProcess (sandboxDir </> "bin" </> exe)
    , clean = do
        b <- Dir.doesDirectoryExist sandboxDir
        when b $ Dir.removeDirectoryRecursive sandboxDir
    }

mkCabalSandbox :: Maybe FilePath -> IO Sandbox
mkCabalSandbox cmdPath = do
  cmd <- maybe (findExecutable "cabal") return cmdPath
  return $ Sandbox {
      update = \sources args -> do
        callProcess cmd ["sandbox", "init"]
        mapM_ (\dir -> callProcess cmd ["sandbox", "add-source", "--snapshot", dir])
              sources
        callProcess cmd $ ["install"] ++ args
    , build = \exe -> callProcess (".cabal-sandbox" </> "bin" </> exe)
    , clean = callProcess cmd ["sandbox", "clean"]
    }

getCabalFile :: IO (FilePath, Dist.PackageDescription)
getCabalFile = do
  cabalFiles <- filter (List.isSuffixOf ".cabal")
                  <$> Dir.getDirectoryContents "."
  case cabalFiles of
    [] -> error "No cabal file found"
    (_:_:_) -> error $ "Multiple cabal files found: " ++ List.intercalate ", " cabalFiles
    [cabalFile] -> do
        pkg <- Dist.flattenPackageDescription
                <$> Dist.readPackageDescription Dist.silent cabalFile
        return (cabalFile, pkg)

configPackageDirs :: [(String, String)] -> [FilePath]
configPackageDirs = maybe [] id
                  . fmap lines
                  . lookup configFieldPackageDirs

configSandbox :: [(String, String)] -> IO Sandbox
configSandbox vars =
  case lookup configFieldSandbox vars of
    Nothing -> mkCabalDevSandbox command
    Just sandbox ->
      case map toLower sandbox of
        "cabal-dev" -> mkCabalDevSandbox command
        "cabal"     -> mkCabalSandbox command
        _           -> error $ "Unknown sandbox type " ++ sandbox
  where command = lookup configFieldSandboxCommand vars

main :: IO ()
main = do
  (cabalFile, pkg) <- getCabalFile
  let config = Dist.customFieldsPD pkg

  sandbox <- configSandbox config

  args <- Env.getArgs
  case args of
    ("update":rest) -> do
      update sandbox
             (configPackageDirs config) $
             [ "--upgrade-dependencies"
             -- These might be defined in the user's cabal config file and effectively double compilation times
             , "--disable-library-profiling"
             , "--disable-executable-profiling" ]
             ++ rest
    _ -> do
      case Dist.executables pkg of
        [] -> error $ "No executables found in " ++ cabalFile
        (exe:_) -> build sandbox
                      (Dist.exeName exe)
                      (["+RTS", "-N", "-RTS"] ++ args)
